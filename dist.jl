using Revise
using Catlab.CategoricalAlgebra
using Catlab.Graphs
using Catlab.Present
using Catlab.Theories
using Test
using DataStructures

using Catlab.CategoricalAlgebra.FinCats: FinCatGraphEq
include("test.jl")
"""
Based on "Categorical Foundations of Distributed Graph Transformation"



"""
# Get schemadesc for Graph (surely there's an easier way?)

const ACSetCat{S} = TypeCat{S,ACSetTransformation}
const Grph = ACSetCat{Graph}
# Functor D: J → Grph (or some other ACSet)
const DistACSet{S,D} = Diagram{id, ACSetCat{S}, D}
# Start with two diagrams: D: J→Grph, D': J'→Grph
# F is a functor J->J'. Φ is a nat.trans. D⇒F⋅D'
const DistACSetHom{S, F,Φ,D} = DiagramHom{id, ACSetCat{S},F,Φ,D}
const DistGraph{D} = DistACSet{Graph,D}
const DistGrphHom{F,Φ,D} = DistACSetHom{Graph,F,Φ,D}


""" Category generated by a finite graph where all paths commute."""
function CommutingGraph(g::HasGraph)
  pths = vcat([zip(ps, ps[2:end]) for ps in values(enumerate_paths(g))
              if length(ps)>1]...)
  FinCatGraphEq(g, ((x,y)->x=>y).(pths))
end

comm_square = Graph(4)
add_edges!(comm_square, [1,1,2,3],[2,3,4,4])
J = FinCatGraph(comm_square, [[1,3]=>[2,4]])

p3 = path_graph(Graph, 3)
p2_w_loop = @acset Graph begin V=2; E=2; src=[1,1]; tgt=[1,2] end
p3_w_loop = @acset Graph begin V=3; E=3; src=[1,1,2]; tgt=[1,2,3] end
p2_w_loops = @acset Graph begin V=2; E=3; src=[1,1,2]; tgt=[1,2,2] end

# we can get to p2 w loops in two equivalent ways
h1 = homomorphism(p3, p2_w_loop; monic=[:E])
h2 = homomorphism(p2_w_loop, p2_w_loops; monic=true)
h3 = ACSetTransformation(p3, p3_w_loop; V=[1,1,2],E=[1,2])
h4 = ACSetTransformation(p3_w_loop, p2_w_loops; V=[1,2,2], E=[1,2,3])
@assert all(is_natural.([h1,h2,h3,h4]))
@assert force(compose(h1,h2)) == force(compose(h3,h4))

# Diagram into Grph
grph_diagram(o::Vector,h::Vector,g::Graph)::Diagram =
  Diagram(FinDomFunctor(o,h, CommutingGraph(g)))

D = Diagram(FinDomFunctor([p3,p2_w_loop,p3_w_loop,p2_w_loops],
                          [h1,h2,h3,h4], J))

# Examples from the paper
@present ThDisC(FreeSchema) begin
  (I, S, C, M)::Ob
  Name::AttrType
  si::Hom(S,I)
  ci::Hom(C,I)
  ms::Hom(M,S)
  mc::Hom(M,C)
  sn::Attr(S,Name)
  cn::Attr(C,Name)
  (from,to,text)::Attr(M,Name)
end

@acset_type DisC_generic(ThDisC)
DisC = DisC_generic{String}

i = @acset DisC begin I=1 end
hi = g -> homomorphism(i,g)
q2_L_ = @acset DisC begin I=1; S=1; si=[1]; cn=["s"] end
q2_R_ =  @acset DisC begin I=1; C=1; ci=[1]; cn=["x"] end
q2_L = grph_diagram([q2_L_], [], Graph(1))
Gspan = @acset Graph begin V=3; E=2; src=[1,1]; tgt=[2,3] end
q2_R = grph_diagram([i, q2_L_, q2_R_], [hi(q2_L_), hi(q2_R_)], Gspan)
g3 = @acset Graph begin V=7; E=6; src=[1,1,2,2,3,3]; tgt=[4,5,4,5,6,7] end
c1, c2 = [@acset(DisC, begin I=1; C=1; ci=[1]; cn=["C$n"] end) for n in 1:2]
s1, s2 = [@acset(DisC, begin I=1; S=1; si=[1]; sn=["S$n"] end) for n in 1:2]
fig3 = Diagram(FinDomFunctor([i,i,i,s1,s2,c1,c2], hi.([s1,s2,s1,s2,c1,c2]),
               FinCatGraph(g3)))
m = DiagramHom{id}([1],[], q2_L, fig3);
r = DiagramHom{id}([1],[], q2_L, q2_R);



@present ThPN(FreeSchema) begin
  (S,I,O,T)::Ob
  is::Hom(I,S)
  it::Hom(I,T)
  os::Hom(O,S)
  ot::Hom(O,T)
end
@acset_type Petri(ThPN)

G = apex(terminal(Petri))
L = Petri(); add_part!(L, :S)
I = Petri(); add_parts!(I, :S, 2)
l = only(homomorphisms(I,L)); m = only(homomorphisms(L, G)); r = id(I)


resDPO = rewrite_match(l,r, m) # DPO
resSqPO= sesqui_pushout_rewrite(l, r, m)
# resSPO = single_pushout_rewrite(l,r,m)
G1, G2 = Graph.([1,2])
rewrite(homomorphism(G2,G1), id(G2), G1)


@present ThSemisimplicialSet(FreeSchema) begin
  (V,E,T) :: Ob
  (d1,d2,d3)::Hom(T,E)
  (src,tgt) :: Hom(E,V)
  compose(d1, src) == compose(d2, src)
  compose(d1, tgt) == compose(d3, tgt)
  compose(d2, tgt) == compose(d3, src)
end
@acset_type SSet(ThSemisimplicialSet)
tri = @acset SSet begin
  T=1;E=3;V=3;src=[1,1,2];tgt=[3,2,3];d1=[1];d2=[2];d3=[3] end
v1 = @acset SSet begin V=1 end
v2 = @acset SSet begin V=2 end
L = homomorphism(v2,v1); R=id(v2); m = CSetTransformation(v1, tri, V=[1]);
A, B = v1, tri;
getS(::StructACSet{S}) where S = S
S = getS(tri)
topo_obs(S)
f = id(v1)

#partial_map_classifier_universal_property(m, id(v1));
resSqPO= sesqui_pushout_rewrite(L, R, m; pres=ThSemisimplicialSet)

# test dangling #
#################

# HElpers
dh = x->dom(hom(x))
cs = x -> [k=>collect(v) for (k,v) in pairs(hom(x).components)]
∂(A) = A ∧ ~A
exp(A) = ~(¬A)
updown(f) = X -> f(inv(f,X))


# correct things that violate are:
function d_viol(f,g)
  A = g(f(dom(f)))
  B = g(dom(g))
  println("A = $(cs(A))")
  println("B = $(cs(B))")
  println("B-A $(cs(B\A))")
  println("∂(A) $(cs(∂(A)))")
  println("∂(B-A) $(cs(∂(B\A)))")
  println("exp(B-A) $(cs(exp(B\A)))")
  println("exp(A) $(cs(exp(A)))")
  println("∂(A) ⟹ ∂(B-A) $(cs(∂(A) ⟹ ∂(B\A)))")
  return (∂(A) ⟹ ∂(B\A)) \ B
end

viol1(f,g) = let A = g(f(dom(f))),B = g(dom(g));  cs(updown(g)(exp(B \ A)) \ B) end
viol2(f,g) = let A = g(f(dom(f))),B = g(dom(g));  cs((exp(B)\exp(A)) \ B) end
viol3(f,g) = let A = g(f(dom(f))),B = g(dom(g));  cs(updown(g)(∂(A) ⟹ ∂(B\A)) \ B) end

# Graphs
V4 = Graph(4)
E2 = Graph(4);
add_edges!(E2,[1,3],[2,4]);
E1 = path_graph(Graph, 2);
f = ACSetTransformation(V4, E2, V=[1,2,3,4]);
g = homomorphism(E2,E1);
@test cs(d_viol(f,g)) == [:V=>[],:E=>[]]

A = @acset Graph begin V=1; E=1; src=[1]; tgt=[1] end
B = @acset Graph begin V=2; E=2; src=[1,2]; tgt=[1,1] end
C = @acset Graph begin V=2; E=3; src=[1,2,2]; tgt=[1,1,1] end
f = homomorphism(A,B); g = homomorphism(B,C;monic=true)
@test !can_pushout_complement(f,g)
@test cs(d_viol(f,g)) == [:V=>[1,2], :E=>[3]]

C = @acset Graph begin V=3; E=3; src=[1,2,3]; tgt=[1,1,1] end
f = homomorphism(A,B); g = homomorphism(B,C;monic=true)
@test can_pushout_complement(f,g)
@test cs(d_viol(f,g)) == [:V=>Int[], :E=>Int[]]


@present ThMon(FreeSchema) begin
  (X)::Ob
  m::Hom(X,X)
end
@acset_type Mon(ThMon)

# SCENARIO 1
A = @acset Mon begin X = 1; m= [1];  end;
B = @acset Mon begin X = 2; m = [1,1];  end;
C = @acset Mon begin X = 3; m=[1,1,1]; end;
f = homomorphism(A,B); g = homomorphism(B,C;monic=true);
@test cs(d_viol(f,g)) == [:X=>Int[]] # + _ +

viol1(f,g)
viol2(f,g)
viol3(f,g)

# Scneario 2
C = @acset Mon begin X = 3; m=[1,1,2]; end;
g = homomorphism(B,C;monic=true);
@test cs(d_viol(f,g)) == [:X=>[1,2,3]]


viol1(f,g)
viol2(f,g)
viol3(f,g)


@present ThMonn(FreeSchema) begin
  (X)::Ob
  m::Hom(X,X)
  n::Hom(X,X)
end
@acset_type Monn(ThMonn)
# Scenario 3
A = @acset Monn begin X = 1; m= [1]; n=[1] end;
B = @acset Monn begin X = 2; m = [1,1]; n=[1,1] end;
C = @acset Monn begin X = 3; m=[1,1,2]; n=[1,1,1] end;
f = homomorphism(A,B); g = homomorphism(B,C;monic=true);
@test cs(d_viol(f,g)) == [:X=>[1,2,3]]

viol1(f,g)
viol2(f,g)
viol3(f,g)


"""
D_VIOL is wrong.

We don't know whether something ends up in boundary of B-A because it's
connected to a B or to an A (some of A is still in B-A b/c of functionality)

Do we subtract boundary of A? This is also wrong because a violation could
be connected both to B of B-A and to A of B-A.
"""

